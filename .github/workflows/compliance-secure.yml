name: PR Compliance Checks (Secure)

on:
  pull_request_target:
    types: [opened, synchronize, reopened, ready_for_review]
    branches: [main]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

# SECURITY NOTE: This workflow uses pull_request_target to access secrets for commenting
# but checks out the PR code in a restricted environment without access to secrets

jobs:
  # Job 1: Checkout PR code safely and run checks without secrets
  code-checks:
    name: Code Quality and Security Checks
    runs-on: ubuntu-latest
    if: ${{ !github.event.pull_request.draft }}
    outputs:
      conventional-commits: ${{ steps.conventional.outputs.result }}
      code-quality: ${{ steps.quality.outputs.result }}
      security-audit: ${{ steps.security.outputs.result }}
      bundle-size: ${{ steps.bundle.outputs.result }}
      file-validation: ${{ steps.files.outputs.result }}
      bundle-details: ${{ steps.bundle.outputs.details }}
    steps:
      # SECURITY: Checkout PR code (untrusted) - no secrets available here
      - name: Checkout PR code
        uses: actions/checkout@v4
        with:
          # IMPORTANT: We checkout the PR head, not the base
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0
          # Explicitly disable persisting credentials
          persist-credentials: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      # Conventional Commits Check (no secrets needed)
      - name: Validate conventional commits
        id: conventional
        run: |
          npm install -g @commitlint/cli @commitlint/config-conventional
          if npx commitlint --from ${{ github.event.pull_request.base.sha }} --to ${{ github.event.pull_request.head.sha }} --config .commitlintrc.warning.json 2>/dev/null; then
            echo "result=success" >> $GITHUB_OUTPUT
          else
            echo "result=warning" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      # Code Quality Checks (no secrets needed)
      - name: Install dependencies
        run: npm ci

      - name: Run TypeScript type checking
        id: quality
        run: |
          if npm run build; then
            echo "result=success" >> $GITHUB_OUTPUT
          else
            echo "result=failure" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Run tests
        run: npm test -- --coverage --passWithNoTests --reporter=verbose
        env:
          VITE_OPENAI_API_KEY: test-key-for-ci
          NODE_OPTIONS: '--unhandled-rejections=strict'
        continue-on-error: true

      # Security Audit (no secrets needed)
      - name: Security checks
        id: security
        run: |
          npm audit fix
          if npm audit --audit-level=moderate; then
            echo "result=success" >> $GITHUB_OUTPUT
          else
            echo "result=failure" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      # Bundle Size Analysis (no secrets needed)
      - name: Build and analyze bundle
        id: bundle
        run: |
          npm run build

          # Calculate bundle sizes
          if [ -d "dist" ]; then
            total_js_size=$(find dist -name "*.js" -not -name "*.map" -exec stat -c%s {} \; 2>/dev/null | awk '{sum+=$1} END {print sum}')
            total_css_size=$(find dist -name "*.css" -exec stat -c%s {} \; 2>/dev/null | awk '{sum+=$1} END {print sum}')
            
            # Store details for reporting
            {
              echo "details<<EOF"
              echo "JS Size: $(( total_js_size / 1024 ))KB"
              echo "CSS Size: $(( total_css_size / 1024 ))KB"
              echo "EOF"
            } >> $GITHUB_OUTPUT
            
            if [ "$total_js_size" -gt 2097152 ]; then
              echo "result=warning" >> $GITHUB_OUTPUT
            else
              echo "result=success" >> $GITHUB_OUTPUT
            fi
          else
            echo "result=failure" >> $GITHUB_OUTPUT
            echo "details=Build failed" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      # File Validation (no secrets needed)
      - name: Check required files
        id: files
        run: |
          required_files=(
            "package.json"
            "README.md"
            "LICENSE"
            ".gitignore"
            "tsconfig.json"
          )

          missing_files=()
          for file in "${required_files[@]}"; do
            if [[ ! -f "$file" ]]; then
              missing_files+=("$file")
            fi
          done

          if [[ ${#missing_files[@]} -gt 0 ]]; then
            echo "result=failure" >> $GITHUB_OUTPUT
          else
            echo "result=success" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      # Save artifacts for the comment job (no sensitive data)
      - name: Save check results
        if: always()
        run: |
          # Use jq to properly escape JSON values, handling multiline strings
          jq -n \
            --arg conventional "${{ steps.conventional.outputs.result }}" \
            --arg quality "${{ steps.quality.outputs.result }}" \
            --arg security "${{ steps.security.outputs.result }}" \
            --arg bundle "${{ steps.bundle.outputs.result }}" \
            --arg details "${{ steps.bundle.outputs.details }}" \
            --arg files "${{ steps.files.outputs.result }}" \
            '{
              conventional_commits: $conventional,
              code_quality: $quality,
              security_audit: $security,
              bundle_size: $bundle,
              bundle_details: $details,
              file_validation: $files
            }' > check-results.json

      - name: Upload results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: check-results
          path: check-results.json
          retention-days: 1

  # Job 2: Comment on PR using base branch code (trusted) with secrets
  comment-results:
    name: Post Results Comment
    runs-on: ubuntu-latest
    needs: [code-checks]
    if: always() && !github.event.pull_request.draft
    permissions:
      pull-requests: write
      issues: write
      contents: read
    steps:
      # SECURITY: Checkout base branch code (trusted) for commenting
      - name: Checkout base branch code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}

      - name: Download check results
        uses: actions/download-artifact@v4
        with:
          name: check-results

      - name: Parse results and comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const results = JSON.parse(fs.readFileSync('check-results.json', 'utf8'));

            // Check if we already commented
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('## üîç PR Compliance Check Results')
            );

            // Build the comment body
            let commentBody = ['## üîç PR Compliance Check Results\n'];

            // Conventional Commits
            if (results.conventional_commits === 'success') {
              commentBody.push('‚úÖ **Conventional Commits**: Passed');
            } else if (results.conventional_commits === 'warning') {
              commentBody.push('‚ö†Ô∏è **Conventional Commits**: Warning (non-blocking)');
              commentBody.push('> Your commit messages don\'t follow the conventional format, but this won\'t block merging.');
            } else {
              commentBody.push('‚ùå **Conventional Commits**: Failed');
            }

            // Code Quality
            if (results.code_quality === 'success') {
              commentBody.push('‚úÖ **Code Quality**: Passed');
            } else {
              commentBody.push('‚ùå **Code Quality**: Failed');
            }

            // Security Audit
            if (results.security_audit === 'success') {
              commentBody.push('‚úÖ **Security Audit**: Passed');
            } else {
              commentBody.push('‚ùå **Security Audit**: Failed');
            }

            // Bundle Size
            if (results.bundle_size === 'success') {
              commentBody.push('‚úÖ **Bundle Size**: Passed');
              if (results.bundle_details && results.bundle_details !== 'Build failed') {
                commentBody.push(`> ${results.bundle_details}`);
              }
            } else if (results.bundle_size === 'warning') {
              commentBody.push('‚ö†Ô∏è **Bundle Size**: Warning - Large bundle detected');
              if (results.bundle_details) {
                commentBody.push(`> ${results.bundle_details}`);
              }
            } else {
              commentBody.push('‚ùå **Bundle Size**: Failed');
            }

            // File Validation
            if (results.file_validation === 'success') {
              commentBody.push('‚úÖ **Required Files**: All present');
            } else {
              commentBody.push('‚ùå **Required Files**: Some files missing');
            }

            // Overall status
            const hasFailures = Object.values(results).some(r => r === 'failure');
            commentBody.push('\n---');
            if (hasFailures) {
              commentBody.push('### ‚ùå Some checks failed - please review and fix the issues above.');
            } else {
              commentBody.push('### ‚úÖ All checks passed!');
            }

            const body = commentBody.join('\n');

            // Create or update comment
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

  # Job 3: Label management using base branch code (trusted)
  pr-labels:
    name: PR Label Management
    runs-on: ubuntu-latest
    if: ${{ !github.event.pull_request.draft }}
    permissions:
      pull-requests: write
      contents: read
    steps:
      # SECURITY: Checkout base branch for labeler config (trusted)
      - name: Checkout base branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}

      - name: Auto-label PR based on changes
        uses: actions/labeler@v5
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          configuration-path: .github/pr-labeler.yml
          sync-labels: true

  # Job 4: CodeQL Analysis (separate for security)
  codeql-analysis:
    name: CodeQL Security Analysis
    runs-on: ubuntu-latest
    if: ${{ !github.event.pull_request.draft }}
    permissions:
      security-events: write
      contents: read
    steps:
      # SECURITY: Checkout PR code for analysis (no secrets)
      - name: Checkout PR code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          persist-credentials: false

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: javascript

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
# SECURITY NOTES:
# 1. This workflow uses pull_request_target for accessing secrets to comment on PRs
# 2. The PR code is checked out without access to secrets in the code-checks job
# 3. Only the base branch code (trusted) has access to secrets for commenting
# 4. All checks run in an isolated environment without secret access
# 5. Results are passed via artifacts, not environment variables
# 6. CodeQL runs separately to ensure proper security scanning
# 7. Permissions are explicitly set per job for least privilege
