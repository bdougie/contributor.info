name: 'Continue Agent Review'
description: 'Perform code review using Continue Agent on pull requests'
author: 'Continue'

inputs:
  continue-api-key:
    description: 'API key for Continue service'
    required: true
  github-token:
    description: 'GitHub token for API access'
    required: true
  continue-org:
    description: 'Continue organization name'
    required: false
    default: 'continuedev'
  continue-config:
    description: 'Continue configuration path'
    required: false
    default: 'continuedev/review-bot'

runs:
  using: 'composite'
  steps:
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Install Continue CLI
      shell: bash
      run: |
        npm install -g @continuedev/cli@latest
        echo "Continue CLI installed successfully"
        cn --version || echo "Continue CLI version check failed"

    - name: Setup Python for GitHub interaction
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install Python dependencies
      shell: bash
      run: |
        pip install PyGithub

    - name: Generate and Run Review
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        CONTINUE_API_KEY: ${{ inputs.continue-api-key }}
        CONTINUE_ORG: ${{ inputs.continue-org }}
        CONTINUE_CONFIG: ${{ inputs.continue-config }}
      run: |
        # Python script to prepare review and post results
        cat > /tmp/continue_review.py << 'EOFPYTHON'
        import os
        import json
        import sys
        import subprocess
        import tempfile
        import re
        import glob
        from datetime import datetime
        from pathlib import Path
        from github import Github

        print("=== Continue Review Agent Starting ===")

        # Get environment variables
        github_token = os.environ.get('GITHUB_TOKEN')
        continue_api_key = os.environ.get('CONTINUE_API_KEY')
        continue_org = os.environ.get('CONTINUE_ORG', 'continuedev')
        continue_config = os.environ.get('CONTINUE_CONFIG', 'continuedev/review-bot')

        print(f"Continue Org: {continue_org}")
        print(f"Continue Config: {continue_config}")
        print(f"API Key present: {bool(continue_api_key)}")

        # Get GitHub context
        github_context = json.loads(os.environ.get('GITHUB_CONTEXT', '{}'))
        repo_name = github_context.get('repository', '')
        event_name = github_context.get('event_name', '')
        
        print(f"Repository: {repo_name}")
        print(f"Event type: {event_name}")
        
        # Get PR number and check for command
        pr_number = None
        command = None
        
        if event_name == 'pull_request':
            pr_number = github_context.get('event', {}).get('pull_request', {}).get('number')
        elif event_name == 'issue_comment':
            pr_number = github_context.get('event', {}).get('issue', {}).get('number')
            # Extract command if present
            comment_body = github_context.get('event', {}).get('comment', {}).get('body', '')
            if '@continue-agent' in comment_body:
                # Extract everything after @continue-agent as the command
                parts = comment_body.split('@continue-agent', 1)
                if len(parts) > 1:
                    command = parts[1].strip()
                    print(f"Command detected: {command}")
        elif event_name == 'workflow_dispatch':
            pr_number = github_context.get('event', {}).get('inputs', {}).get('pr_number')
        
        if not pr_number:
            print("No PR number found, exiting")
            sys.exit(0)

        print(f"PR Number: {pr_number}")

        # Constants for comment management
        COMMENT_MARKER = "<!-- continue-agent-review -->"
        PROGRESS_MARKER = "<!-- continue-agent-in-progress -->"

        # Function to find existing comment
        def find_existing_comment(pr, marker):
            for comment in pr.get_issue_comments():
                if marker in comment.body:
                    return comment
            return None

        # Function to load Continue rules
        def load_continue_rules():
            rules = []
            rules_dir = Path('.continue/rules')
            if not rules_dir.exists():
                print("No .continue/rules directory found")
                return rules
            
            for rule_file in rules_dir.glob('*.md'):
                try:
                    with open(rule_file, 'r') as f:
                        content = f.read()
                        
                    # Parse frontmatter
                    frontmatter = {}
                    if content.startswith('---'):
                        parts = content.split('---', 2)
                        if len(parts) >= 3:
                            frontmatter_text = parts[1].strip()
                            rule_content = parts[2].strip()
                            
                            # Parse YAML-like frontmatter
                            for line in frontmatter_text.split('\n'):
                                if ':' in line:
                                    key, value = line.split(':', 1)
                                    frontmatter[key.strip()] = value.strip().strip('"')
                        else:
                            rule_content = content
                    else:
                        rule_content = content
                    
                    rules.append({
                        'file': rule_file.name,
                        'globs': frontmatter.get('globs', ''),
                        'description': frontmatter.get('description', ''),
                        'alwaysApply': frontmatter.get('alwaysApply', 'true').lower() != 'false',
                        'content': rule_content
                    })
                    print(f"Loaded rule: {rule_file.name}")
                except Exception as e:
                    print(f"Error loading rule {rule_file}: {e}")
            
            return rules

        # Function to match file patterns
        def matches_pattern(filename, pattern):
            if not pattern:
                return False
            # Convert glob pattern to regex
            pattern = pattern.replace('**/', '.*/')
            pattern = pattern.replace('*', '[^/]*')
            pattern = pattern.replace('.', r'\.')
            pattern = pattern.replace('{', '(')
            pattern = pattern.replace('}', ')')
            pattern = pattern.replace(',', '|')
            pattern = '^' + pattern + '$'
            return bool(re.match(pattern, filename))

        try:
            # Initialize GitHub client
            g = Github(github_token)
            repo = g.get_repo(repo_name)
            pr = repo.get_pull(pr_number)
            
            print(f"PR Title: {pr.title}")
            print(f"PR State: {pr.state}")
            
            # Check for existing review comment
            existing_comment = find_existing_comment(pr, COMMENT_MARKER)
            
            # Find previous reviews to track progress
            previous_reviews = []
            review_history = ""
            if existing_comment:
                # Extract previous review points from existing comment
                if "### Previous Feedback" in existing_comment.body:
                    # Parse previous feedback section
                    lines = existing_comment.body.split('\n')
                    in_feedback = False
                    for line in lines:
                        if line.startswith("### Previous Feedback"):
                            in_feedback = True
                            review_history = "### Previous Feedback\n"
                        elif in_feedback and line.startswith("###"):
                            break
                        elif in_feedback and (line.startswith("- ‚úÖ") or line.startswith("- ‚ö†Ô∏è") or line.startswith("- ‚ùå")):
                            previous_reviews.append(line)
            
            # Post initial progress comment
            progress_body = COMMENT_MARKER + "\n"
            progress_body += "## ü§ñ Continue Agent Review\n\n"
            progress_body += "üîÑ **Review in progress...** \n\n"
            progress_body += "I'm analyzing the changes in this pull request. This may take a moment.\n\n"
            progress_body += "### What I'm checking:\n"
            progress_body += "- üìù Code quality and best practices\n"
            progress_body += "- üêõ Potential bugs or logic errors\n"
            progress_body += "- üîí Security vulnerabilities\n"
            progress_body += "- ‚ö° Performance implications\n"
            progress_body += "- üìö Compliance with project rules\n\n"
            if review_history:
                progress_body += review_history + "\n\n"
            progress_body += "---\n"
            progress_body += "*This comment will be updated with the review results shortly...*"
            
            if existing_comment:
                existing_comment.edit(progress_body)
                print(f"Updated existing comment with progress indicator")
            else:
                existing_comment = pr.create_issue_comment(progress_body)
                print(f"Created progress comment ID: {existing_comment.id}")
            
            # Load Continue rules
            rules = load_continue_rules()
            print(f"Loaded {len(rules)} rules")
            
            # Get PR diff and track filenames
            files = pr.get_files()
            diff_content = []
            file_count = 0
            changed_files = []
            
            for file in files:
                file_count += 1
                changed_files.append(file.filename)
                if file.patch:
                    diff_content.append(f"=== File: {file.filename} ===\n{file.patch}")
            
            print(f"Files changed: {file_count}")
            
            # Find applicable rules
            applicable_rules = []
            for rule in rules:
                # Check if rule always applies
                if rule['alwaysApply']:
                    # Skip rules that are marked as alwaysApply: false
                    if rule['description'] not in ['Generate the PRD spec', 'Generate tasks for the agent to complete.', 'Instructions on how to complete tasks']:
                        applicable_rules.append(rule)
                        print(f"Rule '{rule['file']}' always applies")
                # Check if rule matches any changed files
                elif rule['globs']:
                    for filename in changed_files:
                        if matches_pattern(filename, rule['globs']):
                            if rule not in applicable_rules:
                                applicable_rules.append(rule)
                                print(f"Rule '{rule['file']}' applies to {filename}")
                            break
            
            print(f"Found {len(applicable_rules)} applicable rules")
            
            if not diff_content:
                print("No changes to review")
                sys.exit(0)
            
            full_diff = "\n\n".join(diff_content)
            diff_size = len(full_diff)
            print(f"Diff size: {diff_size} characters")
            
            # Truncate if too large
            max_diff_size = 12000
            if diff_size > max_diff_size:
                full_diff = full_diff[:max_diff_size] + "\n\n... (diff truncated)"
            
            # Build rules section for the prompt
            rules_section = ""
            if applicable_rules:
                rules_section = "\n\n## Project-Specific Rules to Apply\n\n"
                rules_section += "The following project-specific rules should be considered in this review:\n\n"
                for rule in applicable_rules:
                    rules_section += f"### {rule['description'] or rule['file']}\n"
                    rules_section += f"{rule['content']}\n\n"
            
            # Create review prompt with optional command
            if command:
                review_prompt = f"""You are reviewing a pull request. The user has provided a specific request: "{command}"

        Pull Request Information
        - Title: {pr.title}
        - Description: {pr.body or 'No description provided'}
        - Files changed: {file_count}
        - Repository: {repo_name}

        User Request
        {command}

        Please address the user's specific request while reviewing the code changes below.
        {rules_section}
        Code Changes
        {full_diff}

        Your Review
        Please provide a review that addresses the user's request: {command}"""
            else:
                review_prompt = f"""You are reviewing a pull request. Please provide constructive feedback.

        Pull Request Information
        - Title: {pr.title}
        - Description: {pr.body or 'No description provided'}
        - Files changed: {file_count}
        - Repository: {repo_name}

        Review Guidelines
        Please focus on:
        1. Code quality and best practices
        2. Potential bugs or logic errors
        3. Security vulnerabilities
        4. Performance implications
        5. Code clarity and maintainability
        6. Missing edge cases or error handling

        If the code looks good, acknowledge that as well. Be specific and actionable in your feedback.
        {rules_section}
        Code Changes
        {full_diff}

        Your Review
        Please provide a comprehensive code review for this pull request."""

            # Write prompt to file for Continue CLI
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                f.write(review_prompt)
                prompt_file = f.name
            
            print(f"Prompt written to: {prompt_file}")
            
            # Call Continue CLI
            print("Calling Continue CLI for review...")
            cmd = [
                'cn',
                '--readonly',
                '--org', continue_org,
                '--config', continue_config,
                '-p', f'@{prompt_file}'  # Use @ to read from file
            ]
            
            print(f"Command: {' '.join(cmd)}")
            
            # Set up environment for Continue CLI
            env = os.environ.copy()
            env['CONTINUE_API_KEY'] = continue_api_key
            
            try:
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    env=env,
                    timeout=60
                )
                
                print(f"Continue CLI exit code: {result.returncode}")
                
                if result.returncode == 0:
                    # Get the plain text response
                    review_text = result.stdout.strip()
                    
                    # Try to parse as JSON and extract content if it's JSON
                    try:
                        response = json.loads(review_text)
                        # Extract the actual review content from JSON structure
                        if isinstance(response, dict):
                            review_text = response.get('response', response.get('content', response.get('message', str(response))))
                    except (json.JSONDecodeError, ValueError):
                        # It's already plain text, use as-is
                        pass
                    
                    # Clean up any remaining JSON artifacts
                    if review_text.startswith('{') and review_text.endswith('}'):
                        try:
                            parsed = json.loads(review_text)
                            if isinstance(parsed, dict) and len(parsed) == 1:
                                review_text = str(list(parsed.values())[0])
                        except:
                            pass
                    
                    if not review_text or review_text.strip() == '':
                        review_text = "The Continue service returned an empty response. Please check the configuration."
                    
                    print("Review generated successfully")
                else:
                    error_msg = result.stderr or result.stdout or 'Unknown error'
                    print(f"Continue CLI error: {error_msg}")
                    review_text = f"Failed to generate review. Continue CLI error:\n```\n{error_msg}\n```"
                    
            except subprocess.TimeoutExpired:
                print("Continue CLI timed out")
                review_text = "Review generation timed out. The diff may be too large or the service may be slow."
            except FileNotFoundError:
                print("Continue CLI not found")
                review_text = "Continue CLI is not installed or not in PATH. Please ensure @continuedev/cli is installed."
            except Exception as e:
                print(f"Error calling Continue CLI: {str(e)}")
                review_text = f"Error calling Continue service: {str(e)}"
            
            finally:
                # Clean up temp file
                try:
                    os.unlink(prompt_file)
                except:
                    pass
            
            # Analyze review for tracking points
            review_points = []
            if "‚úÖ" in review_text or "looks good" in review_text.lower() or "well done" in review_text.lower():
                has_positive = True
            else:
                has_positive = False
            
            # Check if previous issues were addressed
            progress_summary = ""
            if previous_reviews:
                resolved_count = 0
                pending_count = 0
                for prev_item in previous_reviews:
                    # Simple heuristic - if review is positive, mark previous items as likely resolved
                    if has_positive and "‚ùå" in prev_item:
                        resolved_count += 1
                    elif "‚ö†Ô∏è" in prev_item or "‚ùå" in prev_item:
                        pending_count += 1
                
                if resolved_count > 0:
                    progress_summary = f"\n\n### Progress Update\n‚úÖ **{resolved_count} previous issue(s) appear to be resolved!**"
                if pending_count > 0:
                    progress_summary += f"\n‚ö†Ô∏è {pending_count} item(s) may still need attention"
            
            # Extract key points from current review for future tracking
            current_feedback = []
            if "error" in review_text.lower() or "issue" in review_text.lower() or "problem" in review_text.lower():
                current_feedback.append("- ‚ùå Issues identified that need addressing")
            if "warning" in review_text.lower() or "consider" in review_text.lower() or "suggest" in review_text.lower():
                current_feedback.append("- ‚ö†Ô∏è Suggestions for improvement")
            if "good" in review_text.lower() or "excellent" in review_text.lower() or "well" in review_text.lower():
                current_feedback.append("- ‚úÖ Good practices identified")
            
            # Build final comment with proper markdown formatting
            comment_body = COMMENT_MARKER + "\n"
            comment_body += "## ü§ñ Continue Agent Review\n\n"
            
            if command:
                comment_body += f"**Responding to:** `@continue-agent {command}`\n\n"
            else:
                comment_body += "**‚úÖ Review Complete**\n\n"
            
            if progress_summary:
                comment_body += progress_summary + "\n\n"
            
            comment_body += "### Current Review\n\n"
            comment_body += review_text + "\n\n"
            
            if previous_reviews:
                comment_body += "### Previous Feedback\n"
                comment_body += "\n".join(previous_reviews) + "\n\n"
            
            if current_feedback:
                comment_body += "### Current Feedback Summary\n"
                comment_body += "\n".join(current_feedback) + "\n\n"
            
            comment_body += "---\n"
            comment_body += f"*Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')} | Powered by [Continue](https://continue.dev)*"
            
            # Update the existing comment
            print("Updating comment with review...")
            if existing_comment:
                existing_comment.edit(comment_body)
                print(f"Updated comment ID: {existing_comment.id}")
            else:
                # Fallback if somehow the comment was deleted
                comment = pr.create_issue_comment(comment_body)
                print(f"Created new comment ID: {comment.id}")
            
        except Exception as e:
            print(f"Error during review: {str(e)}")
            import traceback
            print(f"Traceback: {traceback.format_exc()}")
            
            # Try to update comment with error
            try:
                error_body = COMMENT_MARKER + "\n"
                error_body += "## ‚ùå Continue Review Error\n\n"
                error_body += "Failed to complete review:\n"
                error_body += "```\n"
                error_body += str(e) + "\n"
                error_body += "```\n\n"
                error_body += "### Please check:\n"
                error_body += "1. CONTINUE_API_KEY is set correctly\n"
                error_body += "2. Continue CLI is installed\n"
                error_body += "3. Workflow logs for details\n\n"
                error_body += "---\n"
                error_body += f"*Error occurred at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}*"
                
                if 'existing_comment' in locals() and existing_comment:
                    existing_comment.edit(error_body)
                    print("Updated comment with error")
                else:
                    g = Github(github_token)
                    repo = g.get_repo(repo_name)
                    pr = repo.get_pull(pr_number)
                    pr.create_issue_comment(error_body)
                    print("Error comment posted")
            except:
                print("Failed to post error comment")
            
            sys.exit(1)
        
        print("=== Continue Review Agent Completed ===")
        EOFPYTHON
        
        # Export GitHub context and run the script
        export GITHUB_CONTEXT='${{ toJson(github) }}'
        python /tmp/continue_review.py

branding:
  icon: 'code'
  color: 'blue'