-- Migration Template
-- Use this template when creating new migrations to ensure local development compatibility
-- 
-- IMPORTANT: Follow these patterns to avoid breaking local development setup
-- 
-- Usage: 
-- 1. Copy this template when creating a new migration
-- 2. Replace placeholders with your actual migration code
-- 3. Run `node scripts/migrations/validate-migrations.js` before committing
-- 4. Local-safe versions will be auto-generated by CI

-- ============================================================================
-- DEPENDENCY CHECKS (Add these at the beginning if your migration needs them)
-- ============================================================================

-- Check for auth schema (if using auth.* functions or tables)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.schemata WHERE schema_name = 'auth') THEN
    RAISE NOTICE 'Auth schema not found. Skipping auth-dependent sections.';
    -- Use this pattern to skip auth-dependent code:
    -- RETURN; -- Uncomment to skip entire migration
  END IF;
END $$;

-- Create required roles if they don't exist
DO $$
BEGIN
  -- Add these for any roles your migration references
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'anon') THEN
    CREATE ROLE anon;
    RAISE NOTICE 'Created role: anon';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'authenticated') THEN
    CREATE ROLE authenticated;
    RAISE NOTICE 'Created role: authenticated';
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'service_role') THEN
    CREATE ROLE service_role;
    RAISE NOTICE 'Created role: service_role';
  END IF;
END $$;

-- ============================================================================
-- EXTENSIONS (Make them optional)
-- ============================================================================

-- Always use IF NOT EXISTS for extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- For extensions that might not be available (like pg_cron), wrap usage:
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_available_extensions WHERE name = 'pg_cron') THEN
    CREATE EXTENSION IF NOT EXISTS pg_cron;
  ELSE
    RAISE NOTICE 'pg_cron extension not available - cron features will be skipped';
  END IF;
END $$;

-- ============================================================================
-- TABLES (Make idempotent)
-- ============================================================================

-- Always use IF NOT EXISTS for tables
CREATE TABLE IF NOT EXISTS your_table_name (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  -- your columns here
  data JSONB
);

-- Add comments to explain the table's purpose
COMMENT ON TABLE your_table_name IS 'Description of what this table stores';

-- ============================================================================
-- INDEXES (Make idempotent)
-- ============================================================================

-- Always use IF NOT EXISTS for indexes
CREATE INDEX IF NOT EXISTS idx_your_table_name_created_at 
  ON your_table_name(created_at);

-- ============================================================================
-- FUNCTIONS (Use CREATE OR REPLACE)
-- ============================================================================

CREATE OR REPLACE FUNCTION your_function_name()
RETURNS TRIGGER AS $$
BEGIN
  -- Your function logic here
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- TRIGGERS (Check if table exists first)
-- ============================================================================

DO $$
BEGIN
  -- Check if the table exists before creating trigger
  IF EXISTS (SELECT 1 FROM information_schema.tables 
             WHERE table_name = 'your_table_name') THEN
    
    -- Drop trigger if exists (for idempotency)
    DROP TRIGGER IF EXISTS your_trigger_name ON your_table_name;
    
    -- Create trigger
    CREATE TRIGGER your_trigger_name
      BEFORE UPDATE ON your_table_name
      FOR EACH ROW
      EXECUTE FUNCTION your_function_name();
  END IF;
END $$;

-- ============================================================================
-- RLS POLICIES (Check for auth before using auth functions)
-- ============================================================================

-- Enable RLS
ALTER TABLE your_table_name ENABLE ROW LEVEL SECURITY;

-- Conditional RLS policy (only if auth is available)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.schemata WHERE schema_name = 'auth') THEN
    -- Drop existing policy for idempotency
    DROP POLICY IF EXISTS "Users can view own data" ON your_table_name;
    
    -- Create policy using auth
    CREATE POLICY "Users can view own data" ON your_table_name
      FOR SELECT
      USING (auth.uid() = user_id);
  ELSE
    -- Alternative policy without auth (allow all for local dev)
    DROP POLICY IF EXISTS "Allow all for local dev" ON your_table_name;
    
    CREATE POLICY "Allow all for local dev" ON your_table_name
      FOR ALL
      USING (true);
  END IF;
END $$;

-- ============================================================================
-- GRANTS (Make conditional)
-- ============================================================================

-- Conditional grants (only if roles exist)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'authenticated') THEN
    GRANT SELECT, INSERT, UPDATE ON your_table_name TO authenticated;
  END IF;
  
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'service_role') THEN
    GRANT ALL ON your_table_name TO service_role;
  END IF;
  
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'anon') THEN
    GRANT SELECT ON your_table_name TO anon;
  END IF;
END $$;

-- ============================================================================
-- CRON JOBS (Make optional for pg_cron)
-- ============================================================================

DO $$
BEGIN
  -- Check if pg_cron is available
  IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_cron') THEN
    -- Schedule your cron job
    SELECT cron.schedule(
      'your_job_name',
      '0 0 * * *', -- Daily at midnight
      $$SELECT your_function_name();$$
    );
  ELSE
    RAISE NOTICE 'pg_cron not available - scheduled jobs will not be created';
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    RAISE NOTICE 'Could not create cron job: %', SQLERRM;
END $$;

-- ============================================================================
-- DATA MIGRATIONS (Make safe)
-- ============================================================================

-- Use transactions for data migrations
BEGIN;

-- Check before inserting to avoid duplicates
INSERT INTO your_table_name (id, data)
SELECT 'known-uuid-here', '{"key": "value"}'::jsonb
WHERE NOT EXISTS (
  SELECT 1 FROM your_table_name WHERE id = 'known-uuid-here'
);

COMMIT;

-- ============================================================================
-- CLEANUP (If modifying existing objects)
-- ============================================================================

-- Drop old objects safely
DROP TABLE IF EXISTS old_table_name CASCADE;
DROP FUNCTION IF EXISTS old_function_name() CASCADE;
DROP TRIGGER IF EXISTS old_trigger_name ON table_name;

-- ============================================================================
-- VALIDATION
-- ============================================================================

-- Add a simple validation at the end
DO $$
DECLARE
  table_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO table_count
  FROM information_schema.tables
  WHERE table_schema = 'public'
  AND table_name = 'your_table_name';
  
  IF table_count = 1 THEN
    RAISE NOTICE '✅ Migration completed successfully';
  ELSE
    RAISE WARNING '⚠️ Table your_table_name was not created';
  END IF;
END $$;