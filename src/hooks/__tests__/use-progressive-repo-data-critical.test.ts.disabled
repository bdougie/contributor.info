import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { renderHook, waitFor, cleanup } from '@testing-library/react';

// Simple mocking
vi.mock('@/lib/supabase-direct-commits', () => ({
  fetchDirectCommitsWithDatabaseFallback: vi.fn(),
}));

vi.mock('@/lib/supabase-pr-data-smart', () => ({
  fetchPRDataSmart: vi.fn(),
}));

vi.mock('@/lib/utils', () => ({
  calculateLotteryFactor: vi.fn(),
}));

vi.mock('@/lib/simple-logging', () => ({
  setApplicationContext: vi.fn(),
  startSpan: vi.fn((options, fn) => fn({ setStatus: vi.fn() })),
}));

import { useProgressiveRepoData } from '../use-progressive-repo-data';
import { setupBasicMocks, cleanupMocks, mockPRData } from './test-utils';
import { fetchPRDataSmart } from '@/lib/supabase-pr-data-smart';
import { fetchDirectCommitsWithDatabaseFallback } from '@/lib/supabase-direct-commits';
import { calculateLotteryFactor } from '@/lib/utils';

describe('useProgressiveRepoData - Critical Stage', () => {
  const fetchPRDataMock = fetchPRDataSmart as ReturnType<typeof vi.fn>;
  const fetchDirectCommitsMock = fetchDirectCommitsWithDatabaseFallback as ReturnType<typeof vi.fn>;
  const calculateLotteryFactorMock = calculateLotteryFactor as ReturnType<typeof vi.fn>;

  beforeEach(() => {
    setupBasicMocks();
    vi.clearAllMocks();
    
    // Default successful response
    fetchPRDataMock.mockResolvedValue({
      data: mockPRData,
      status: 'success',
      message: 'Data loaded successfully',
    });
    fetchDirectCommitsMock.mockResolvedValue({ commits: [], totalCommits: 0 });
    calculateLotteryFactorMock.mockReturnValue({ 
      factor: 0.5, 
      description: 'Test', 
      category: 'balanced' 
    });
  });

  afterEach(() => {
    cleanup();
    cleanupMocks();
  });

  it('should load critical data first', async () => {
    const { result } = renderHook(() => 
      useProgressiveRepoData('owner', 'repo', '90d', false)
    );

    // Wait for critical stage to complete
    await waitFor(() => {
      expect(result.current.currentStage).toBe('critical');
      expect(result.current.stageProgress.critical).toBe(true);
    }, { timeout: 5000 });

    // Check basic info is populated
    await waitFor(() => {
      expect(result.current.basicInfo).toBeDefined();
      expect(result.current.basicInfo?.prCount).toBe(3);
      expect(result.current.basicInfo?.contributorCount).toBe(2);
    }, { timeout: 5000 });
  });

  it('should handle empty data in critical stage', async () => {
    fetchPRDataMock.mockResolvedValue({
      data: [],
      status: 'success',
      message: 'No data found',
    });

    const { result } = renderHook(() => 
      useProgressiveRepoData('owner', 'repo', '90d', false)
    );

    await waitFor(() => {
      expect(result.current.stageProgress.critical).toBe(true);
    }, { timeout: 5000 });

    expect(result.current.basicInfo?.prCount).toBe(0);
    expect(result.current.basicInfo?.contributorCount).toBe(0);
  });

  it('should handle errors in critical stage', async () => {
    const errorMessage = 'Failed to fetch data';
    fetchPRDataMock.mockRejectedValue(new Error(errorMessage));

    const { result } = renderHook(() => 
      useProgressiveRepoData('owner', 'repo', '90d', false)
    );

    await waitFor(() => {
      expect(result.current.basicInfo).toBe(null);
      expect(result.current.stats.error).toBe(errorMessage);
    }, { timeout: 5000 });
  });

  it('should extract top contributors correctly', async () => {
    const { result } = renderHook(() => 
      useProgressiveRepoData('owner', 'repo', '90d', false)
    );

    await waitFor(() => {
      expect(result.current.basicInfo?.topContributors).toBeDefined();
    }, { timeout: 5000 });

    const topContributors = result.current.basicInfo?.topContributors || [];
    expect(topContributors).toHaveLength(2);
    expect(topContributors[0].login).toBe('user1');
    expect(topContributors[0].count).toBe(2); // user1 has 2 PRs
  });
});