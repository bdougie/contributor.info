import { PullRequest, Repository } from '../types/github';
import { ContributorInsights } from './insights';
import { SimilarIssue } from './similarity';
import { ReviewerSuggestion } from './reviewers';

interface CommentData {
  pullRequest: PullRequest;
  repository: Repository;
  contributorInsights: ContributorInsights;
  similarIssues: SimilarIssue[];
  reviewerSuggestions: ReviewerSuggestion[];
}

/**
 * Format a PR comment with insights
 */
export function formatPRComment(data: CommentData): string {
  const { contributorInsights, similarIssues, reviewerSuggestions } = data;
  
  let comment = `## 🎯 Contributor Insights

**@${contributorInsights.login}** has contributed:
- 📊 ${contributorInsights.totalPRs} PRs (${contributorInsights.mergedPRs} merged, ${contributorInsights.firstTimeApprovalRate}% first-time approval rate)
- 🏆 Primary expertise: ${contributorInsights.expertise.join(', ') || 'Various areas'}
- 🕐 Active hours: ${contributorInsights.activeHours}
- 🔄 Last active: ${contributorInsights.lastActive}
`;

  // Add similar issues section if any found
  if (similarIssues.length > 0) {
    comment += `
### 🔍 Related Issues & Context
`;
    
    // Group by relationship type
    const implementsIssues = similarIssues.filter(i => i.relationship === 'implements');
    const fixesIssues = similarIssues.filter(i => i.relationship === 'fixes');
    const relatedIssues = similarIssues.filter(i => i.relationship === 'relates_to' || i.relationship === 'similar');
    
    if (implementsIssues.length > 0) {
      comment += `**This PR implements:**\n`;
      implementsIssues.forEach(({ issue, reasons }) => {
        comment += `- 🎯 **#${issue.number}** "${issue.title}"\n`;
      });
    }
    
    if (fixesIssues.length > 0) {
      comment += `\n**This PR may fix:**\n`;
      fixesIssues.forEach(({ issue, reasons }) => {
        const priority = issue.labels?.find((l: any) => l.name.includes('priority'))?.name || '';
        comment += `- ✅ **#${issue.number}** "${issue.title}"${priority ? ` (${priority})` : ''}\n`;
      });
    }
    
    if (relatedIssues.length > 0) {
      comment += `\n**Related issues:**\n`;
      relatedIssues.forEach(({ issue, reasons, similarityScore }) => {
        const state = issue.state === 'closed' ? '(Closed)' : '(Open)';
        comment += `- 🔄 **#${issue.number}** "${issue.title}" ${state}\n`;
        if (reasons.length > 0) {
          comment += `  - ${reasons.join(', ')}\n`;
        }
      });
    }
  }

  // Add reviewer suggestions
  if (reviewerSuggestions.length > 0) {
    comment += `
### 💡 Suggested Reviewers
Based on code ownership and expertise:\n`;
    
    reviewerSuggestions.forEach(reviewer => {
      comment += `- **@${reviewer.login}**`;
      if (reviewer.name) {
        comment += ` (${reviewer.name})`;
      }
      comment += ` - ${reviewer.reasons.join(', ')}`;
      if (reviewer.stats.avgResponseTime !== 'Unknown') {
        comment += ` (avg response: ${reviewer.stats.avgResponseTime})`;
      }
      comment += '\n';
    });
  }

  // Add potential impact section if issues are being fixed
  const fixedIssues = similarIssues.filter(i => i.relationship === 'fixes');
  if (fixedIssues.length > 0) {
    comment += `
### 📈 Potential Impact
`;
    
    // Count affected users (mock data for now)
    const affectedUsers = fixedIssues.length * 3;
    comment += `- **Fixes ${fixedIssues.length} issue${fixedIssues.length > 1 ? 's' : ''}** potentially affecting ${affectedUsers}+ users\n`;
    
    // List enabled features
    const enabledFeatures = similarIssues
      .filter(i => i.reasons.some(r => r.includes('Enables')))
      .map(i => `#${i.issue.number}`);
    
    if (enabledFeatures.length > 0) {
      comment += `- **Enables**: ${enabledFeatures.join(', ')}\n`;
    }
  }

  // Add footer
  comment += `
---
*Generated by [contributor.info](https://contributor.info) • [Install on more repos](https://github.com/apps/contributor-info) • [Get full analytics](https://contributor.info/upgrade)*`;

  return comment;
}

/**
 * Format a minimal PR comment (for users who prefer less detail)
 */
export function formatMinimalPRComment(data: CommentData): string {
  const { contributorInsights, reviewerSuggestions, similarIssues } = data;
  
  let comment = `**@${contributorInsights.login}**: ${contributorInsights.mergedPRs}/${contributorInsights.totalPRs} PRs merged`;
  
  if (reviewerSuggestions.length > 0) {
    comment += ` • Suggested reviewers: ${reviewerSuggestions.slice(0, 2).map(r => `@${r.login}`).join(', ')}`;
  }
  
  const fixCount = similarIssues.filter(i => i.relationship === 'fixes').length;
  if (fixCount > 0) {
    comment += ` • Fixes ${fixCount} issue${fixCount > 1 ? 's' : ''}`;
  }
  
  comment += ` • [Details](https://contributor.info)`;
  
  return comment;
}

/**
 * Format a welcome message for first-time contributors
 */
export function formatWelcomeComment(contributor: string, repository: Repository): string {
  return `## 👋 Welcome @${contributor}!

Thank you for your first contribution to **${repository.full_name}**! 

We use [contributor.info](https://contributor.info) to help identify the best reviewers for your PR and provide context about related issues. Your PR will be reviewed soon!

If you have any questions, feel free to ask in the comments below.

---
*Generated by [contributor.info](https://contributor.info)*`;
}

/**
 * Format an error message when insights can't be generated
 */
export function formatErrorComment(): string {
  return `## 🎯 Contributor Insights

We're currently experiencing issues generating insights for this PR. The review process will continue as normal.

If this persists, please contact support at support@contributor.info.

---
*[contributor.info](https://contributor.info)*`;
}