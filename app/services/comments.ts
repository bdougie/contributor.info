import { PullRequest, Repository, Issue } from '../types/github';
import { ContributorInsights } from './insights';
import { SimilarIssue } from './similarity';
import { ReviewerSuggestion } from './reviewers';
import { ContextualItem } from './issue-context';
import { ContributorConfig } from './contributor-config';

interface CommentData {
  pullRequest: PullRequest;
  repository: Repository;
  contributorInsights: ContributorInsights;
  similarIssues: SimilarIssue[];
  reviewerSuggestions: ReviewerSuggestion[];
  hasCodeOwners?: boolean;
  config?: ContributorConfig;
}

/**
 * Format a username based on mention settings
 */
function formatUsername(username: string, config?: ContributorConfig): string {
  // Input validation
  if (!username || typeof username !== 'string') {
    throw new Error('Invalid username provided');
  }
  
  // Basic sanitization for markdown injection
  // Remove characters that could break markdown links
  const sanitizedUsername = username.replace(/[[\]()]/g, '');
  
  const allowMentions = config?.features?.github_mentions ?? false;
  return allowMentions ? `@${sanitizedUsername}` : `[${sanitizedUsername}](https://github.com/${sanitizedUsername})`;
}

/**
 * Format a PR comment with insights
 */
export function formatPRComment(data: CommentData): string {
  const { contributorInsights, similarIssues, reviewerSuggestions, config } = data;
  
  let comment = `## contributor.info stats

| Metric | Value |
|--------|-------|
| **PRs** | ${contributorInsights.mergedPRs}/${contributorInsights.totalPRs} merged |
| **Reviews** | ${contributorInsights.reviewsGiven} given |
| **Comments** | ${contributorInsights.commentsLeft} |
| **Approval Rate** | ${contributorInsights.firstTimeApprovalRate}% |
`;

  // Add reviewer suggestions
  if (reviewerSuggestions.length > 0) {
    comment += `
## Suggested Reviewers
`;
    reviewerSuggestions.forEach(reviewer => {
      const mainReason = reviewer.reasons[0] || 'Code expertise';
      comment += `- **${formatUsername(reviewer.login, config)}** - ${mainReason}\n`;
    });
  }

  // Add related issues (simplified)
  const fixesIssues = similarIssues.filter(i => i.relationship === 'fixes');
  const relatedIssues = similarIssues.filter(i => 
    ['relates_to', 'similar', 'implements'].includes(i.relationship)
  );
  
  if (fixesIssues.length > 0) {
    comment += `
## May Fix
`;
    fixesIssues.forEach(({ issue }) => {
      comment += `- [#${issue.number}](${issue.html_url}) ${issue.title}\n`;
    });
  }
  
  if (relatedIssues.length > 0) {
    comment += `
## Related
`;
    relatedIssues.slice(0, 3).forEach(({ issue }) => {
      comment += `- [#${issue.number}](${issue.html_url}) ${issue.title}\n`;
    });
  }

  // Footer with repository-specific dashboard link
  const repoUrl = `https://contributor.info/${data.repository.full_name}`;
  comment += `
---
*This comment was generated by [contributor.info](${repoUrl}) - providing contributor insights and reviewer suggestions. [Install on your repositories](https://github.com/apps/contributor-info)*`;

  return comment;
}

/**
 * Format a minimal PR comment (for users who prefer less detail)
 */
export function formatMinimalPRComment(data: CommentData): string {
  const { contributorInsights, reviewerSuggestions, similarIssues, config, repository } = data;
  const repoUrl = `https://contributor.info/${repository.full_name}`;
  
  let comment = `**${formatUsername(contributorInsights.login, config)}**: ${contributorInsights.mergedPRs}/${contributorInsights.totalPRs} PRs merged`;
  
  if (reviewerSuggestions.length > 0) {
    comment += ` â€¢ Suggested reviewers: ${reviewerSuggestions.slice(0, 2).map(r => formatUsername(r.login, config)).join(', ')}`;
  }
  
  const fixCount = similarIssues.filter(i => i.relationship === 'fixes').length;
  if (fixCount > 0) {
    comment += ` â€¢ Fixes ${fixCount} issue${fixCount > 1 ? 's' : ''}`;
  }
  
  comment += ` â€¢ [Details](${repoUrl})`;
  
  // Footer with repository-specific dashboard link
  comment += `
---
*This comment was generated by [contributor.info](${repoUrl}) - providing contributor insights and reviewer suggestions. [Install on your repositories](https://github.com/apps/contributor-info)*`;
  
  return comment;
}

/**
 * Format a welcome message for first-time contributors
 */
export function formatWelcomeComment(contributor: string, repository: Repository): string {
  const repoUrl = `https://contributor.info/${repository.full_name}`;
  return `## ðŸ‘‹ Welcome @${contributor}!

Thank you for your first contribution to **${repository.full_name}**! 

We use [contributor.info](${repoUrl}) to help identify the best reviewers for your PR and provide context about related issues. Your PR will be reviewed soon!

If you have any questions, feel free to ask in the comments below.

---
*This comment was generated by [contributor.info](${repoUrl}) - providing contributor insights and reviewer suggestions. [Install on your repositories](https://github.com/apps/contributor-info)*`;
}

/**
 * Format an error message when insights can't be generated
 */
export function formatErrorComment(repository?: Repository): string {
  const repoUrl = repository ? `https://contributor.info/${repository.full_name}` : 'https://contributor.info';
  return `## ðŸŽ¯ Contributor Insights

We're currently experiencing issues generating insights for this PR. The review process will continue as normal.

If this persists, please contact support at support@contributor.info.

---
*This comment was generated by [contributor.info](${repoUrl}) - providing contributor insights and reviewer suggestions. [Install on your repositories](https://github.com/apps/contributor-info)*`;
}

interface ContextCommentData {
  pullRequest: Issue; // GitHub Issue object (which represents the PR)
  repository: Repository;
  contextualItems: ContextualItem[];
  changedFiles: string[];
}

/**
 * Format a comment response to the .issues command
 */
export function formatContextComment(data: ContextCommentData): string {
  const { contextualItems, changedFiles, repository } = data;
  const repoUrl = `https://contributor.info/${repository.full_name}`;
  
  if (contextualItems.length === 0) {
    return `## ðŸ“‹ Issue Context Analysis

No related issues or pull requests found for this PR.

This might be because:
- This is working on a new area of the codebase
- Related issues haven't been indexed yet
- The changes are too unique to match existing work

---
*Generated by [contributor.info](${repoUrl}) â€¢ Use \`.issues\` in any PR comment to analyze context*`;
  }

  let comment = `## ðŸ“‹ Issue Context Analysis

Based on the files changed in this PR, here are related issues and pull requests:

`;

  // Group items by relationship
  const mayFix = contextualItems.filter(item => item.relationship === 'may_fix');
  const relatedWork = contextualItems.filter(item => item.relationship === 'related_work');
  const mayConflict = contextualItems.filter(item => item.relationship === 'may_conflict');
  const similarChanges = contextualItems.filter(item => item.relationship === 'similar_changes');

  // Show items that may be fixed
  if (mayFix.length > 0) {
    comment += `### ðŸ”§ May Fix These Issues\n`;
    mayFix.forEach(item => {
      const matchPercent = Math.round((item.similarity_score * 0.6 + item.file_overlap_score * 0.4) * 100);
      comment += `- **#${item.number}**: "${item.title}" (${matchPercent}% match)\n`;
      if (item.reasons.length > 0) {
        comment += `  - ${item.reasons.join(', ')}\n`;
      }
    });
    comment += '\n';
  }

  // Show related recent work
  if (relatedWork.length > 0) {
    comment += `### ðŸ”„ Related Recent Work\n`;
    relatedWork.forEach(item => {
      const stateIcon = item.state === 'closed' ? 'âœ…' : 'ðŸ”µ';
      const typeLabel = item.type === 'pull_request' ? 'PR' : 'Issue';
      comment += `- ${stateIcon} **${typeLabel} #${item.number}**: "${item.title}"\n`;
      if (item.reasons.length > 0) {
        comment += `  - ${item.reasons.join(', ')}\n`;
      }
    });
    comment += '\n';
  }

  // Show potential conflicts
  if (mayConflict.length > 0) {
    comment += `### âš ï¸ Potential Conflicts\n`;
    mayConflict.forEach(item => {
      comment += `- **PR #${item.number}**: "${item.title}" (currently open)\n`;
      if (item.reasons.length > 0) {
        comment += `  - ${item.reasons.join(', ')}\n`;
      }
    });
    comment += '\n';
  }

  // Show similar historical changes
  if (similarChanges.length > 0) {
    comment += `### ðŸ“Š Similar Historical Changes\n`;
    similarChanges.forEach(item => {
      const matchPercent = Math.round(item.similarity_score * 100);
      const typeLabel = item.type === 'pull_request' ? 'PR' : 'Issue';
      comment += `- **${typeLabel} #${item.number}**: "${item.title}" (${matchPercent}% similarity)\n`;
    });
    comment += '\n';
  }

  // Add file context
  if (changedFiles.length > 0) {
    comment += `### ðŸ“ Changed Files\n`;
    comment += `This PR modifies ${changedFiles.length} file${changedFiles.length > 1 ? 's' : ''}`;
    if (changedFiles.length <= 5) {
      comment += `: ${changedFiles.map(f => `\`${f}\``).join(', ')}`;
    } else {
      const dirs = new Set(changedFiles.map(f => f.split('/')[0]));
      comment += ` across ${dirs.size} director${dirs.size > 1 ? 'ies' : 'y'}`;
    }
    comment += '\n\n';
  }

  // Add footer
  comment += `---
*This comment was generated by [contributor.info](${repoUrl}) - providing contributor insights and reviewer suggestions. [Install on your repositories](https://github.com/apps/contributor-info)*`;

  return comment;
}