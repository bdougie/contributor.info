import { PullRequest, Repository } from '../types/github';
import { ContributorInsights } from './insights';
import { SimilarIssue } from './similarity';
import { ReviewerSuggestion } from './reviewers';
import { ContextualItem } from './issue-context';

interface CommentData {
  pullRequest: PullRequest;
  repository: Repository;
  contributorInsights: ContributorInsights;
  similarIssues: SimilarIssue[];
  reviewerSuggestions: ReviewerSuggestion[];
  hasCodeOwners?: boolean;
}

/**
 * Format a PR comment with insights
 */
export function formatPRComment(data: CommentData): string {
  const { contributorInsights, similarIssues, reviewerSuggestions } = data;
  
  let comment = `## Contributor Stats

| Metric | Value |
|--------|-------|
| **PRs** | ${contributorInsights.mergedPRs}/${contributorInsights.totalPRs} merged |
| **Reviews** | ${contributorInsights.reviewsGiven} given |
| **Comments** | ${contributorInsights.commentsLeft} |
| **Approval Rate** | ${contributorInsights.firstTimeApprovalRate}% |
`;

  // Add reviewer suggestions
  if (reviewerSuggestions.length > 0) {
    comment += `
## Suggested Reviewers
`;
    reviewerSuggestions.forEach(reviewer => {
      const mainReason = reviewer.reasons[0] || 'Code expertise';
      comment += `- **@${reviewer.login}** - ${mainReason}\n`;
    });
  }

  // Add related issues (simplified)
  const fixesIssues = similarIssues.filter(i => i.relationship === 'fixes');
  const relatedIssues = similarIssues.filter(i => 
    i.relationship === 'relates_to' || 
    i.relationship === 'similar' || 
    i.relationship === 'implements'
  );
  
  if (fixesIssues.length > 0) {
    comment += `
## May Fix
`;
    fixesIssues.forEach(({ issue }) => {
      comment += `- [#${issue.number}](${issue.html_url}) ${issue.title}\n`;
    });
  }
  
  if (relatedIssues.length > 0) {
    comment += `
## Related
`;
    relatedIssues.slice(0, 3).forEach(({ issue }) => {
      comment += `- [#${issue.number}](${issue.html_url}) ${issue.title}\n`;
    });
  }

  // Minimal footer
  comment += `
---
*[contributor.info](https://contributor.info)*`;

  return comment;
}

/**
 * Format a minimal PR comment (for users who prefer less detail)
 */
export function formatMinimalPRComment(data: CommentData): string {
  const { contributorInsights, reviewerSuggestions, similarIssues } = data;
  
  let comment = `**@${contributorInsights.login}**: ${contributorInsights.mergedPRs}/${contributorInsights.totalPRs} PRs merged`;
  
  if (reviewerSuggestions.length > 0) {
    comment += ` • Suggested reviewers: ${reviewerSuggestions.slice(0, 2).map(r => `@${r.login}`).join(', ')}`;
  }
  
  const fixCount = similarIssues.filter(i => i.relationship === 'fixes').length;
  if (fixCount > 0) {
    comment += ` • Fixes ${fixCount} issue${fixCount > 1 ? 's' : ''}`;
  }
  
  comment += ` • [Details](https://contributor.info)`;
  
  return comment;
}

/**
 * Format a welcome message for first-time contributors
 */
export function formatWelcomeComment(contributor: string, repository: Repository): string {
  return `## 👋 Welcome @${contributor}!

Thank you for your first contribution to **${repository.full_name}**! 

We use [contributor.info](https://contributor.info) to help identify the best reviewers for your PR and provide context about related issues. Your PR will be reviewed soon!

If you have any questions, feel free to ask in the comments below.

---
*Generated by [contributor.info](https://contributor.info)*`;
}

/**
 * Format an error message when insights can't be generated
 */
export function formatErrorComment(): string {
  return `## 🎯 Contributor Insights

We're currently experiencing issues generating insights for this PR. The review process will continue as normal.

If this persists, please contact support at support@contributor.info.

---
*[contributor.info](https://contributor.info)*`;
}

interface ContextCommentData {
  pullRequest: any; // GitHub Issue object (which represents the PR)
  repository: Repository;
  contextualItems: ContextualItem[];
  changedFiles: string[];
}

/**
 * Format a comment response to the .issues command
 */
export function formatContextComment(data: ContextCommentData): string {
  const { contextualItems, changedFiles } = data;
  
  if (contextualItems.length === 0) {
    return `## 📋 Issue Context Analysis

No related issues or pull requests found for this PR.

This might be because:
- This is working on a new area of the codebase
- Related issues haven't been indexed yet
- The changes are too unique to match existing work

---
*Generated by [contributor.info](https://contributor.info) • Use \`.issues\` in any PR comment to analyze context*`;
  }

  let comment = `## 📋 Issue Context Analysis

Based on the files changed in this PR, here are related issues and pull requests:

`;

  // Group items by relationship
  const mayFix = contextualItems.filter(item => item.relationship === 'may_fix');
  const relatedWork = contextualItems.filter(item => item.relationship === 'related_work');
  const mayConflict = contextualItems.filter(item => item.relationship === 'may_conflict');
  const similarChanges = contextualItems.filter(item => item.relationship === 'similar_changes');

  // Show items that may be fixed
  if (mayFix.length > 0) {
    comment += `### 🔧 May Fix These Issues\n`;
    mayFix.forEach(item => {
      const matchPercent = Math.round((item.similarity_score * 0.6 + item.file_overlap_score * 0.4) * 100);
      comment += `- **#${item.number}**: "${item.title}" (${matchPercent}% match)\n`;
      if (item.reasons.length > 0) {
        comment += `  - ${item.reasons.join(', ')}\n`;
      }
    });
    comment += '\n';
  }

  // Show related recent work
  if (relatedWork.length > 0) {
    comment += `### 🔄 Related Recent Work\n`;
    relatedWork.forEach(item => {
      const stateIcon = item.state === 'closed' ? '✅' : '🔵';
      const typeLabel = item.type === 'pull_request' ? 'PR' : 'Issue';
      comment += `- ${stateIcon} **${typeLabel} #${item.number}**: "${item.title}"\n`;
      if (item.reasons.length > 0) {
        comment += `  - ${item.reasons.join(', ')}\n`;
      }
    });
    comment += '\n';
  }

  // Show potential conflicts
  if (mayConflict.length > 0) {
    comment += `### ⚠️ Potential Conflicts\n`;
    mayConflict.forEach(item => {
      comment += `- **PR #${item.number}**: "${item.title}" (currently open)\n`;
      if (item.reasons.length > 0) {
        comment += `  - ${item.reasons.join(', ')}\n`;
      }
    });
    comment += '\n';
  }

  // Show similar historical changes
  if (similarChanges.length > 0) {
    comment += `### 📊 Similar Historical Changes\n`;
    similarChanges.forEach(item => {
      const matchPercent = Math.round(item.similarity_score * 100);
      const typeLabel = item.type === 'pull_request' ? 'PR' : 'Issue';
      comment += `- **${typeLabel} #${item.number}**: "${item.title}" (${matchPercent}% similarity)\n`;
    });
    comment += '\n';
  }

  // Add file context
  if (changedFiles.length > 0) {
    comment += `### 📁 Changed Files\n`;
    comment += `This PR modifies ${changedFiles.length} file${changedFiles.length > 1 ? 's' : ''}`;
    if (changedFiles.length <= 5) {
      comment += `: ${changedFiles.map(f => `\`${f}\``).join(', ')}`;
    } else {
      const dirs = new Set(changedFiles.map(f => f.split('/')[0]));
      comment += ` across ${dirs.size} director${dirs.size > 1 ? 'ies' : 'y'}`;
    }
    comment += '\n\n';
  }

  // Add footer
  comment += `---
*Generated based on semantic analysis of ${contextualItems.length} related items • [Learn more](https://contributor.info/docs/issue-context)*`;

  return comment;
}